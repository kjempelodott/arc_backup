#!/bin/bash

>> umask_and_sourcewithargs
>
# Overide umask of execution node
(sometime values are really strange)
umask 077

# source with arguments for DASH shells
sourcewithargs() {
  script=$1
  shift
  . $script
}

>


>> user_env
>
# Setting environment variables as specified by user
@ENVS *ENV *VAL
export %(ENV)s=%(VAL)
@
>


>> grid_globalid
>
export GRID_GLOBAL_JOBID='gsiftp://%(GM_HOST)s:%(GM_PORT)s%(GM_MOUNTPOINT)s/%(GRIDID)s'
>


>> local_transfer
>
RUNTIME_CONTROL_DIR=%(RUNTIME_CONTROLDIR)
>


>> runtime_env
>
RUNTIME_JOB_DIR=%(SESSIONDIR)s
RUNTIME_JOB_STDIN=%(STDIN)s
RUNTIME_JOB_STDOUT=%(STDOUT)s
RUNTIME_JOB_STDERR=%(STDERR)s
RUNTIME_JOB_DIAG=%(SESSIONDIR)s.diag
if [ ! -z "$RUNTIME_GRIDAREA_DIR" ] ; then
  RUNTIME_JOB_DIR=$RUNTIME_GRIDAREA_DIR/`basename $RUNTIME_JOB_DIR`
  RUNTIME_JOB_STDIN=`echo "$RUNTIME_JOB_STDIN" | sed "s#^$RUNTIME_JOB_DIR#$RUNTIME_GRIDAREA_DIR#"`
  RUNTIME_JOB_STDOUT=`echo "$RUNTIME_JOB_STDOUT" | sed "s#^$RUNTIME_JOB_DIR#$RUNTIME_GRIDAREA_DIR#"`
  RUNTIME_JOB_STDERR=`echo "$RUNTIME_JOB_STDERR" | sed "s#^$RUNTIME_JOB_DIR#$RUNTIME_GRIDAREA_DIR#"`
  RUNTIME_JOB_DIAG=`echo "$RUNTIME_JOB_DIAG" | sed "s#^$RUNTIME_JOB_DIR#$RUNTIME_GRIDAREA_DIR#"`
  RUNTIME_CONTROL_DIR=`echo "$RUNTIME_CONTROL_DIR" | sed "s#^$RUNTIME_JOB_DIR#$RUNTIME_GRIDAREA_DIR#"`
fi

>


>> move_files_to_node
>
UNTIME_LOCAL_SCRATCH_DIR=${RUNTIME_LOCAL_SCRATCH_DIR:-%(LOCAL_SCRATCHDIR)s}
UNTIME_FRONTEND_SEES_NODE=${RUNTIME_FRONTEND_SEES_NODE:-%(SHARED_SCRATCHDIR)s}
UNTIME_NODE_SEES_FRONTEND=${RUNTIME_NODE_SEES_FRONTEND:-%s(IS_SHARED_FILESYSTEM)s} 
if [ ! -z "$RUNTIME_LOCAL_SCRATCH_DIR" ] && ! -z "$RUNTIME_NODE_SEES_FRONTEND" ]; then
  RUNTIME_NODE_JOB_DIR="$RUNTIME_LOCAL_SCRATCH_DIR"/`basename "$RUNTIME_JOB_DIR"`
  rm -rf "$RUNTIME_NODE_JOB_DIR"
  mkdir -p "$RUNTIME_NODE_JOB_DIR"
  # move directory contents
  for f in "$RUNTIME_JOB_DIR"/.* "$RUNTIME_JOB_DIR"/*; do 
    [ "$f" = "$RUNTIME_JOB_DIR/*" ] && continue
    # glob failed, no files
    [ "$f" = "$RUNTIME_JOB_DIR/." ] && continue
    [ "$f" = "$RUNTIME_JOB_DIR/.." ] && continue
    [ "$f" = "$RUNTIME_JOB_DIR/.diag" ] && continue
    [ "$f" = "$RUNTIME_JOB_DIR/.comment" ] && continue
    if ! mv "$f" "$RUNTIME_NODE_JOB_DIR"; then
      echo "Failed to move '$f' to '$RUNTIME_NODE_JOB_DIR'" 1>&2
      exit 1
    fi
  done
  if [ ! -z "$RUNTIME_FRONTEND_SEES_NODE" ] ; then
    # creating link for whole directory
     ln -s "$RUNTIME_FRONTEND_SEES_NODE" `basename "$RUNTIME_JOB_DIR"` "$RUNTIME_JOB_DIR"
  else
    # keep stdout, stderr and control directory on frontend
    # recreate job directory
    mkdir -p "$RUNTIME_JOB_DIR"
    # make those files
    mkdir -p `dirname "$RUNTIME_JOB_STDOUT"`
    mkdir -p `dirname "$RUNTIME_JOB_STDERR"`
    touch "$RUNTIME_JOB_STDOUT"
    touch "$RUNTIME_JOB_STDERR"
    RUNTIME_JOB_STDOUT__=`echo "$RUNTIME_JOB_STDOUT" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
    RUNTIME_JOB_STDERR__=`echo "$RUNTIME_JOB_STDERR" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
    rm "$RUNTIME_JOB_STDOUT__" 2>/dev/null
    rm "$RUNTIME_JOB_STDERR__" 2>/dev/null
    if [ ! -z "$RUNTIME_JOB_STDOUT__" ] && [ "$RUNTIME_JOB_STDOUT" != "$RUNTIME_JOB_STDOUT__" ]; then
      ln -s "$RUNTIME_JOB_STDOUT" "$RUNTIME_JOB_STDOUT__"
    fi
    if [ "$RUNTIME_JOB_STDOUT__" != "$RUNTIME_JOB_STDERR__" ] ; then
      if [ ! -z "$RUNTIME_JOB_STDERR__" ] && [ "$RUNTIME_JOB_STDERR" != "$RUNTIME_JOB_STDERR__" ]; then
        ln -s "$RUNTIME_JOB_STDERR" "$RUNTIME_JOB_STDERR__"
      fi
    fi
    if [ ! -z "$RUNTIME_CONTROL_DIR" ] ; then
      # move control directory back to frontend
      RUNTIME_CONTROL_DIR__=`echo "$RUNTIME_CONTROL_DIR" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
      mv "$RUNTIME_CONTROL_DIR__" "$RUNTIME_CONTROL_DIR"
    fi
  fi
  # adjust stdin,stdout & stderr pointers
  RUNTIME_JOB_STDIN=`echo "$RUNTIME_JOB_STDIN" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
  RUNTIME_JOB_STDOUT=`echo "$RUNTIME_JOB_STDOUT" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
  RUNTIME_JOB_STDERR=`echo "$RUNTIME_JOB_STDERR" | sed "s#^${RUNTIME_JOB_DIR}#${RUNTIME_NODE_JOB_DIR}#"`
  RUNTIME_FRONTEND_JOB_DIR="$RUNTIME_JOB_DIR"
  RUNTIME_JOB_DIR="$RUNTIME_NODE_JOB_DIR"
fi
if [ -z "$RUNTIME_NODE_SEES_FRONTEND" ] ;

>


>> download_input_files
>
ARC_LOCATION=${ARC_LOCATION:-%(ARC_LOCATION)s}
GLOBUS_LOCATION=${GLOBUS_LOCATION:-%s}
DOWNLOADER=${DOWNLOADER:-%(ARC_TOOLSDIR)s/downloader}
if [ -z "$ARC_LOCATION" ] ; then
  echo 'Variable ARC_LOCATION is not set' 1>&2
  exit 1
fi
if [ -z "$GLOBUS_LOCATION" ] ; then
  echo 'Variable GLOBUS_LOCATION is not set' 1>&2
  exit 1
fi
  export GLOBUS_LOCATION
  export ARC_LOCATION
if [ "x$LD_LIBRARY_PATH" = "x" ]; then
  export LD_LIBRARY_PATH="$GLOBUS_LOCATION/lib"
else
  export LD_LIBRARY_PATH="$GLOBUS_LOCATION/lib:$LD_LIBRARY_PATH"
fi
export SASL_PATH="$GLOBUS_LOCATION/lib/sasl"
export X509_USER_KEY="${RUNTIME_CONTROL_DIR}/job.local.proxy"
export X509_USER_CERT="${RUNTIME_CONTROL_DIR}/job.local.proxy"
export X509_USER_PROXY="${RUNTIME_CONTROL_DIR}/job.local.proxy"
unset X509_RUN_AS_SERVER
$DOWNLOADER -p -c 'local' "$RUNTIME_CONTROL_DIR" "$RUNTIME_JOB_DIR" 2>>${RUNTIME_CONTROL_DIR}/job.local.errors
if [ $? -ne '0' ] ; then
  echo 'ERROR: Downloader failed.' 1>&2
  exit 1
fi

>


>> rte_stage1
>
# Running runtime scripts
export RUNTIME_CONFIG_DIR=${RUNTIME_CONFIG_DIR:-%(RUNTIME_DIR}
runtimeenvironments=
if [ ! -z "$RUNTIME_CONFIG_DIR" ] ; then
@RTES *RTE *OPTS
  if [ -r "${RUNTIME_CONFIG_DIR}/%(RTE)s" ] ; then
    runtimeenvironments="${runtimeenvironments}:%(RTE)s";
    cmdl=${RUNTIME_CONFIG_DIR}/%(RTE)s
    sourcewithargs $cmdl 1 %s{OPTS}s
    if [ $? -ne '0' ] ; then
      echo "Runtime %(RTE)s script failed " 1>&2
      echo "Runtime %(RTE)s script failed " 1>"$RUNTIME_JOB_DIAG"
      exit 1
    fi
  fi
@
fi
echo "runtimeenvironments=$runtimeenvironments" >> "$RUNTIME_JOB_DIAG"

>


>> cd_and_run
>
RESULT=0

# Changing to session directory
HOME=$RUNTIME_JOB_DIR
export HOME
if ! cd "$RUNTIME_JOB_DIR"; then
  echo "Failed to switch to '$RUNTIME_JOB_DIR'" 1>&2
  RESULT=1
fi
if [ ! -z "$RESULT" ] && [ "$RESULT" != 0 ]; then
  exit $RESULT
fi

nodename=`%(NODENAME)s`
echo "nodename=$nodename" >> "$RUNTIME_JOB_DIAG"
echo "Processors=%(PROCESSORS)s" >> "$RUNTIME_JOB_DIAG"
executable='%(EXEC)s'
# Check if executable exists
if [ ! -f "$executable" ]; then
  echo "Path \\"$executable\\" does not seem to exist" 1>$RUNTIME_JOB_STDOUT 2>$RUNTIME_JOB_STDERR 1>&2
  exit 1
fi

# See if executable is a script, and extract the name of the interpreter
line1=`dd if="$executable" count=1 2>/dev/null | head -n 1`
command=`echo $line1 | sed -n \'s/^#! *//p\'`
interpreter=`echo $command | awk \'{print $1}\'`
if [ "$interpreter" = /usr/bin/env ]; then
  interpreter=`echo $command | awk \'{print $2}\'`
fi
# If it\'s a script and the interpreter is not found ...
[ "x$interpreter" = x ] || type "$interpreter" > /dev/null 2>&1 || {

  echo "Cannot run $executable: $interpreter: not found" 1>$RUNTIME_JOB_STDOUT 2>$RUNTIME_JOB_STDERR 1>&2
  exit 1; }

GNU_TIME='%(GNU_TIME)s'
if [ ! -z "$GNU_TIME" ] && ! "$GNU_TIME" --version >/dev/null 2>&1; then
  echo "WARNING: GNU time not found at: $GNU_TIME" 2>&1
  GNU_TIME=
fi

if [ -z "$GNU_TIME" ] ; then
  "%(EXEC)s" "%(ARGS)s" %(STDIN_REDIR)s %(STDOUT_REDIR)s %(STDERR_REDIR)s
else
  $GNU_TIME -o "$RUNTIME_JOB_DIAG" -a -f '
  WallTime=%es\\nKernelTime=%Ss\\nUserTime=%Us\\nCPUUsage=%P
  MaxResidentMemory=%MkB\\nAverageResidentMemory=%tkB
  AverageTotalMemory=%KkB\\nAverageUnsharedMemory=%DkB
  AverageUnsharedStack=%pkB\\nAverageSharedMemory=%XkB
  PageSize=%ZB\\nMajorPageFaults=%F\\nMinorPageFaults=%R
  Swaps=%W\\nForcedSwitches=%c\\nWaitSwitches=%w
  Inputs=%I\\nOutputs=%O\\nSocketReceived=%r\\nSocketSent=%s
  Signals=%k'
  "%(EXEC)s" "%(ARGS)s" %(STDIN_REDIR)s %(STDOUT_REDIR)s %(STDERR_REDIR)s
fi
RESULT=$?

>


>> rte_stage2
>
if [ -r "${RUNTIME_CONFIG_DIR}/%s" ] ; then
@RTES *RTE *OPTS
  if [ -r "${RUNTIME_CONFIG_DIR}/%(RTE)s" ] ; then\
    cmdl=${RUNTIME_CONFIG_DIR}/%(RTE)s
    sourcewithargs $cmdl 2 %(OPTS)s
  fi
@
fi

>


>> upload_output_file
>



>